import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { describe, expect, it } from 'vitest';
import { Alert, Button } from '../../../index';
import { render } from '../index';
describe('isMatch()', () => {
    it('should allow assertions against a mix of text and element nodes', () => {
        const { getRootNode, isMatch } = render(_jsxs(_Fragment, { children: [_jsx(Button, { variant: "primary", children: "Click me!" }), _jsx(Alert, { title: "My Alert" }), "Hello"] }));
        const rootNode = getRootNode();
        const children = rootNode.children;
        const buttonNode = children[0];
        const alertNode = children[1];
        const textNode = children[2];
        if (isMatch(buttonNode, Button)) {
            expect(buttonNode.props.variant).toEqual('primary');
        }
        else {
            throw new Error('Expected button node');
        }
        expect(isMatch(alertNode, Button)).toBe(false);
        expect(isMatch(textNode, Button)).toBe(false);
    });
    it('should allow a custom matcher function to be provided', () => {
        const { getRootNode, isMatch } = render(_jsxs(_Fragment, { children: [_jsx(Button, { variant: "primary", children: "Primary" }), _jsx(Button, { variant: "secondary", children: "Secondary" }), _jsx(Alert, { title: "My Alert" }), "Hello"] }));
        const rootNode = getRootNode();
        const children = rootNode.children;
        const primaryButtonNode = children[0];
        const secondaryButtonNode = children[1];
        const alertNode = children[2];
        const textNode = children[3];
        const matcher = (node) => node.props.variant === 'primary';
        if (isMatch(primaryButtonNode, Button, matcher)) {
            expect(primaryButtonNode.props.variant).toEqual('primary');
        }
        else {
            throw new Error('Expected button node');
        }
        expect(isMatch(secondaryButtonNode, Button, matcher)).toBe(false);
        expect(isMatch(alertNode, Button, matcher)).toBe(false);
        expect(isMatch(textNode, Button, matcher)).toBe(false);
    });
    it('should allow a partial props object to be provided for matching', () => {
        const { getRootNode, isMatch } = render(_jsxs(_Fragment, { children: [_jsx(Button, { variant: "primary", children: "Primary" }), _jsx(Button, { variant: "secondary", children: "Secondary" }), _jsx(Alert, { title: "My Alert" }), "Hello"] }));
        const rootNode = getRootNode();
        const children = rootNode.children;
        const primaryButtonNode = children[0];
        const secondaryButtonNode = children[1];
        const alertNode = children[2];
        const textNode = children[3];
        const matcher = { variant: 'primary' };
        if (isMatch(primaryButtonNode, Button, matcher)) {
            expect(primaryButtonNode.props.variant).toEqual('primary');
        }
        else {
            throw new Error('Expected button node');
        }
        expect(isMatch(secondaryButtonNode, Button, matcher)).toBe(false);
        expect(isMatch(alertNode, Button, matcher)).toBe(false);
        expect(isMatch(textNode, Button, matcher)).toBe(false);
    });
});
