import { createRemoteRoot } from '@remote-ui/core';
import { createRoot as createReactRoot } from '@remote-ui/react';
import { convertRemoteRoot } from './internal/convert';
import { createDocument } from './internal/document';
import { InvalidComponentsError, WaitForTimeoutError } from './internal/errors';
import { isMatch } from './internal/match';
import { find, findAll, findAllChildren, findChild, maybeFind, maybeFindChild, } from './internal/query';
import { createRootNode } from './internal/root';
import { createDeferred } from './internal/utils/promise-utils';
const DEFAULT_WAIT_FOR_TIMEOUT_IN_MS = 1000;
const DEFAULT_WAIT_FOR_OPTIONS = {
    timeoutInMs: DEFAULT_WAIT_FOR_TIMEOUT_IN_MS,
};
/**
 * Renders a UI extension component using React so that assertions can be made against the rendered output.
 *
 * @param node The React node to render.
 * @returns A render result object that can be used to query the rendered DOM.
 */
export const render = (node) => {
    let dirty = true;
    let waitForChecksQueued = false;
    let waitForList = [];
    const runWaitForChecks = () => {
        waitForChecksQueued = false;
        waitForList = waitForList.filter((waitFor) => {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            const renderedRootNode = getLatestRootNode();
            if (renderedRootNode.document.hasInvalidComponentNames()) {
                // Reject the waitFor promise if we detect invalid components in the rendered output.
                waitFor.deferred.reject(new InvalidComponentsError(renderedRootNode));
                if (waitFor.setTimeoutId) {
                    // Clear the timeout so that we don't reject the promise if the check passes before the timeout expires.
                    // Technically, calling reject on a promise that has already been resolved is a no-op.
                    clearTimeout(waitFor.setTimeoutId);
                }
                return false;
            }
            try {
                waitFor.check(); // Run the user provided check function.
                if (waitFor.setTimeoutId) {
                    // Clear the timeout so that we don't reject the promise if the check passes before the timeout expires.
                    // Technically, calling reject on a promise that has already been resolved is a no-op.
                    clearTimeout(waitFor.setTimeoutId);
                }
                waitFor.deferred.resolve(); // Resolve the promise that was originally returned by the waitFor function.
                return false; // Remove the waitFor from the list since the check passed and we resolved the promise
            }
            catch (error) {
                return true; // Keep the waitFor in the list since the check failed and we didn't resolve the promise.
            }
        });
    };
    /**
     * This function will be invoked any time there are changes to the remote DOM.
     * We don't really care what the changes were because we are not actually sending them
     * to a host page. We are only interested in the fact that the DOM has been updated
     * so that we can know that we need rebuild our own tree of rendered nodes.
     */
    const remoteChannel = () => {
        dirty = true;
        if (waitForList.length > 0) {
            // Even though @remote-ui/core is notifying us that the DOM has been updated, it hasn't actually
            // applied the DOMs to the remote DOM representation. Therefore, we need to queue a microtask to
            // run the waitFor checks at the end of the event loop to give the DOM a chance to be updated...
            if (!waitForChecksQueued) {
                waitForChecksQueued = true;
                queueMicrotask(runWaitForChecks);
            }
        }
    };
    const remoteRoot = createRemoteRoot(remoteChannel);
    const reactRoot = createReactRoot(remoteRoot);
    reactRoot.render(node);
    remoteRoot.mount();
    let maybeRenderedRootNode;
    /**
     * Returns the latest rendered root node. If the root node has not been rendered yet, it will be rendered.
     * If there were no changes to the remote DOM then the previously rendered root node will be returned.
     */
    const getLatestRootNode = () => {
        if (maybeRenderedRootNode && !dirty) {
            // Return the previously rendered root node if there were no changes to the remote DOM.
            return maybeRenderedRootNode;
        }
        // Create a new document for the next rendered DOM tree
        const document = createDocument({
            getLatestRootNode,
        });
        const nextRootNode = createRootNode(document);
        document.rootNode = nextRootNode;
        // Convert the tree of remote nodes to a tree of rendered nodes.
        convertRemoteRoot(nextRootNode, remoteRoot);
        maybeRenderedRootNode = nextRootNode;
        dirty = false;
        return maybeRenderedRootNode;
    };
    const initialRenderedRootNode = getLatestRootNode();
    if (initialRenderedRootNode.document.hasInvalidComponentNames()) {
        throw new InvalidComponentsError(initialRenderedRootNode);
    }
    return {
        find: (component, matcher) => {
            return find(getLatestRootNode(), component, matcher);
        },
        findAll: (component, matcher) => {
            return findAll(getLatestRootNode(), component, matcher);
        },
        findChild: (component, matcher) => {
            return findChild(getLatestRootNode(), component, matcher);
        },
        findAllChildren: (component, matcher) => {
            return findAllChildren(getLatestRootNode(), component, matcher);
        },
        maybeFindChild: (component, matcher) => {
            return maybeFindChild(getLatestRootNode(), component, matcher);
        },
        maybeFind: (component, matcher) => {
            return maybeFind(getLatestRootNode(), component, matcher);
        },
        waitFor: (check, options = DEFAULT_WAIT_FOR_OPTIONS) => {
            const { timeoutInMs = DEFAULT_WAIT_FOR_TIMEOUT_IN_MS } = options;
            try {
                check();
                // Nothing to wait for since the check passed! Resolve the promise immediately.
                return Promise.resolve();
            }
            catch (error) {
                // If the check failed then we need to put it in the waitForList so that we
                // can check it again later. We return a promise that will be resolved when
                // the provided check passes.
            }
            const deferred = createDeferred();
            const waitFor = { check, deferred, setTimeoutId: null };
            waitForList.push(waitFor);
            if (timeoutInMs > 0) {
                waitFor.setTimeoutId = setTimeout(() => {
                    // Remove the wait for from the list since the timeout expired and we rejected the promise.
                    waitForList = waitForList.filter((currentWaitFor) => currentWaitFor !== waitFor);
                    deferred.reject(new WaitForTimeoutError(timeoutInMs));
                }, timeoutInMs);
            }
            return deferred.promise;
        },
        debugLog: (label) => {
            return getLatestRootNode().debugLog(label);
        },
        getRootNode: () => {
            return getLatestRootNode();
        },
        isMatch: (targetNode, component, matcher) => {
            return isMatch(targetNode, component, matcher);
        },
    };
};
