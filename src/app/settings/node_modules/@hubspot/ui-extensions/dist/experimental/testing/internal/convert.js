import { KIND_COMPONENT, KIND_FRAGMENT, KIND_TEXT, } from '@remote-ui/core';
import { createElementNode } from './element';
import { InvalidFragmentPropArrayError } from './errors';
import { createFragmentNode } from './fragment';
import { createTextNode } from './text';
import { isRenderedTextNode } from '../type-utils';
import { __hubSpotComponentRegistry } from '../../../__synced__/remoteComponents.synced';
import { EMPTY_CHILDREN } from './constants';
/* eslint-disable @typescript-eslint/no-use-before-define */
/**
 * Converts a remote props object to a props object that can be attached to a rendered element node.
 *
 * @param document The document to use for creating new nodes.
 * @param componentName The name of the component to convert the props for.
 * @param remoteProps The remote props object to convert.
 * @returns The rendered props object.
 */
const convertRemoteProps = (document, componentName, remoteProps) => {
    if (typeof remoteProps !== 'object' || remoteProps == null) {
        return {};
    }
    const convertedProps = {};
    for (const [propName, remotePropValue] of Object.entries(remoteProps)) {
        if (propName === 'children') {
            // Skip over `children` props since we created nested nodes in our tree for children
            continue;
        }
        if (__hubSpotComponentRegistry.isComponentFragmentProp(componentName, propName)) {
            if (Array.isArray(remotePropValue)) {
                throw new InvalidFragmentPropArrayError(componentName, propName);
            }
            const fragmentNode = createFragmentNode(document);
            if (remotePropValue == null) {
                fragmentNode.children = EMPTY_CHILDREN;
            }
            else if (typeof remotePropValue === 'string') {
                const text = remotePropValue;
                fragmentNode.text = text;
                fragmentNode.children = [createTextNode(text)];
            }
            else if (remotePropValue.kind === KIND_FRAGMENT) {
                convertRemoteChildren(fragmentNode, remotePropValue);
            }
            convertedProps[propName] = fragmentNode;
        }
        else {
            convertedProps[propName] = remotePropValue;
        }
    }
    return convertedProps;
};
/**
 * Converts a remote child node to a rendered child node.
 *
 * @param document The document to use for creating new nodes.
 * @param remoteChild The remote child node to convert.
 *
 * @returns The rendered child node.
 */
const convertChildNode = (document, remoteChild) => {
    if (remoteChild.kind === KIND_TEXT) {
        return createTextNode(remoteChild);
    }
    else if (remoteChild.kind === KIND_COMPONENT) {
        const name = remoteChild.type;
        const props = convertRemoteProps(document, name, remoteChild.props);
        const elementNode = createElementNode(document, name, props);
        if (!__hubSpotComponentRegistry.isAllowedComponentName(name)) {
            document.addInvalidComponentName(name);
        }
        convertRemoteChildren(elementNode, remoteChild);
        return elementNode;
    }
    else {
        throw new Error(`Illegal State. Unknown remote child. (${JSON.stringify(remoteChild)})`);
    }
};
/**
 * Converts the children a remote parent node to a rendered parent node. After conversion, the rendered parent node will
 * have its children set to the converted children.
 *
 * @param parentNode The rendered parent node to convert.
 * @param remoteParentNode The remote parent node to convert.
 */
const convertRemoteChildren = (parentNode, remoteParentNode) => {
    const { document } = parentNode;
    const remoteChildren = remoteParentNode.children;
    if (remoteChildren == null) {
        return;
    }
    if (typeof remoteChildren === 'string') {
        const text = remoteChildren;
        parentNode.text = text;
        parentNode.children = [createTextNode(text)];
        return;
    }
    let text = null;
    const children = [];
    let lastRenderedChild;
    for (const remoteChild of remoteChildren) {
        if (remoteChild.kind === KIND_TEXT) {
            const currentChildText = remoteChild.text;
            if (text == null) {
                text = currentChildText;
            }
            else {
                text += currentChildText;
            }
            if (lastRenderedChild && isRenderedTextNode(lastRenderedChild)) {
                // We normalize text nodes by combining consecutive text nodes into a single text node.
                lastRenderedChild.text += remoteChild.text;
                continue;
            }
        }
        const renderedChild = convertChildNode(document, remoteChild);
        children.push(renderedChild);
        lastRenderedChild = renderedChild;
    }
    parentNode.text = text;
    parentNode.children = children;
};
/**
 * Converts a remote root node to a rendered root node. After conversion, the rendered root node will
 * have its children set to the converted children.
 *
 * @param rootNode The rendered root node to convert.
 * @param remoteRoot The remote root node to convert.
 */
export const convertRemoteRoot = (rootNode, remoteRoot) => {
    convertRemoteChildren(rootNode, remoteRoot);
};
