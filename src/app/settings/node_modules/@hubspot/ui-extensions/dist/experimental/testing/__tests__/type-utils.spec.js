import { jsx as _jsx } from "react/jsx-runtime";
import { describe, expect, it } from 'vitest';
import { Button, ButtonRow, Text } from '../../../index';
import { render } from '../index';
import { isRenderedElementNode, isRenderedFragmentNode, isRenderedRootNode, isRenderedTextNode, } from '../type-utils';
import { RenderedNodeType } from '../types';
const TestComponent = () => (_jsx(Button, { overlay: _jsx(Text, { children: "Hello" }), children: "Text content" }));
const setupTestNodes = () => {
    const { find, getRootNode } = render(_jsx(TestComponent, {}));
    const elementNode = find(Button);
    const rootNode = getRootNode();
    const textNode = find(Button).children[0];
    const fragmentNode = find(Button).props.overlay;
    return {
        elementNode,
        textNode,
        rootNode,
        fragmentNode,
    };
};
describe('type guard functions', () => {
    describe('isRenderedElementNode()', () => {
        it('should return true for an element node', () => {
            const { elementNode } = setupTestNodes();
            expect(isRenderedElementNode(elementNode)).toBe(true);
            expect(elementNode.nodeType).toBe(RenderedNodeType.Element);
        });
        it('should return false for a text node', () => {
            const { textNode } = setupTestNodes();
            expect(isRenderedElementNode(textNode)).toBe(false);
        });
        it('should return false for a root node', () => {
            const { rootNode } = setupTestNodes();
            expect(isRenderedElementNode(rootNode)).toBe(false);
        });
        it('should return false for a fragment node', () => {
            const { fragmentNode } = setupTestNodes();
            expect(isRenderedElementNode(fragmentNode)).toBe(false);
        });
        it('should return false for null', () => {
            expect(isRenderedElementNode(null)).toBe(false);
        });
        it('should return false for undefined', () => {
            expect(isRenderedElementNode(undefined)).toBe(false);
        });
    });
    describe('isRenderedTextNode()', () => {
        it('should return true for a text node', () => {
            const { textNode } = setupTestNodes();
            expect(isRenderedTextNode(textNode)).toBe(true);
            expect(textNode.nodeType).toBe(RenderedNodeType.Text);
        });
        it('should return false for an element node', () => {
            const { elementNode } = setupTestNodes();
            expect(isRenderedTextNode(elementNode)).toBe(false);
        });
        it('should return false for a root node', () => {
            const { rootNode } = setupTestNodes();
            expect(isRenderedTextNode(rootNode)).toBe(false);
        });
        it('should return false for a fragment node', () => {
            const { fragmentNode } = setupTestNodes();
            expect(isRenderedTextNode(fragmentNode)).toBe(false);
        });
        it('should return false for null', () => {
            expect(isRenderedTextNode(null)).toBe(false);
        });
        it('should return false for undefined', () => {
            expect(isRenderedTextNode(undefined)).toBe(false);
        });
    });
    describe('isRenderedRootNode()', () => {
        it('should return true for a root node', () => {
            const { rootNode } = setupTestNodes();
            expect(isRenderedRootNode(rootNode)).toBe(true);
            expect(rootNode.nodeType).toBe(RenderedNodeType.Root);
        });
        it('should return false for an element node', () => {
            const { elementNode } = setupTestNodes();
            expect(isRenderedRootNode(elementNode)).toBe(false);
        });
        it('should return false for a text node', () => {
            const { textNode } = setupTestNodes();
            expect(isRenderedRootNode(textNode)).toBe(false);
        });
        it('should return false for a fragment node', () => {
            const { fragmentNode } = setupTestNodes();
            expect(isRenderedRootNode(fragmentNode)).toBe(false);
        });
        it('should return false for null', () => {
            expect(isRenderedRootNode(null)).toBe(false);
        });
        it('should return false for undefined', () => {
            expect(isRenderedRootNode(undefined)).toBe(false);
        });
    });
    describe('isRenderedFragmentNode()', () => {
        it('should return true for a fragment node', () => {
            const { fragmentNode } = setupTestNodes();
            expect(isRenderedFragmentNode(fragmentNode)).toBe(true);
            expect(fragmentNode.nodeType).toBe(RenderedNodeType.Fragment);
        });
        it('should return false for an element node', () => {
            const { elementNode } = setupTestNodes();
            expect(isRenderedFragmentNode(elementNode)).toBe(false);
        });
        it('should return false for a text node', () => {
            const { textNode } = setupTestNodes();
            expect(isRenderedFragmentNode(textNode)).toBe(false);
        });
        it('should return false for a root node', () => {
            const { rootNode } = setupTestNodes();
            expect(isRenderedFragmentNode(rootNode)).toBe(false);
        });
        it('should return false for null', () => {
            expect(isRenderedFragmentNode(null)).toBe(false);
        });
        it('should return false for undefined', () => {
            expect(isRenderedFragmentNode(undefined)).toBe(false);
        });
    });
    describe('type narrowing', () => {
        it('should correctly narrow types for element nodes', () => {
            const { find } = render(_jsx(ButtonRow, { children: _jsx(Button, { variant: "primary", children: "Click me" }) }));
            const buttonRow = find(ButtonRow);
            const firstChild = buttonRow.children[0];
            if (isRenderedElementNode(firstChild)) {
                expect(firstChild.name).toBe('Button');
                expect(firstChild.props.variant).toBe('primary');
            }
            else {
                throw new Error('Expected element node');
            }
        });
        it('should correctly narrow types for text nodes', () => {
            const { textNode } = setupTestNodes();
            if (isRenderedTextNode(textNode)) {
                expect(textNode.text).toBe('Text content');
            }
            else {
                throw new Error('Expected text node');
            }
        });
        it('should correctly narrow types for root nodes', () => {
            const { rootNode } = setupTestNodes();
            if (isRenderedRootNode(rootNode)) {
                expect(rootNode.children.length).toBeGreaterThan(0);
            }
            else {
                throw new Error('Expected root node');
            }
        });
        it('should correctly narrow types for fragment nodes', () => {
            const { fragmentNode } = setupTestNodes();
            if (isRenderedFragmentNode(fragmentNode)) {
                expect(fragmentNode.children.length).toBe(1);
            }
            else {
                throw new Error('Expected fragment node');
            }
        });
    });
});
